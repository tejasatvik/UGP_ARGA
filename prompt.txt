You are a highly analytical AI researcher specializing in visual abstraction reasoning.
Your task is to study abstract visual representations and infer the underlying conceptual or structural abstraction they represent.

In this experiment, we work within the ARGA (Abstraction Reasoning Graph Analysis) framework.  
ARGA aims to understand how intelligent systems — both humans and AI models — infer and reason about abstract relationships from visual or structural information.

The task is provided as a JSON object with two main fields:
	
"train": A list of one or more examples. Each example has:

	"input": a 2D grid representing the pre-transformation image.

	"output": a 2D grid showing the desired post-transformation result.

"test": An optional list of test examples with:

	"input" grids (to predict on)

	"output" grids (if provided, only used for validation, not prediction)

Each colour	is represented by an integer (e.g., 0 for background, other numbers for colored regions). Your task is to examine the visual and structural relationship between input and output in the "train" examples to infer the underlying abstraction.

If "test" is present, you may optionally observe its structure to check consistency — but base your top 3 abstraction guesses primarily on the "train" examples.


We use **abstractions** — conceptual templates that describe the *type* of relationship or transformation underlying an image.

The background color by default is black if it is present in the grid(0) else it is the color which occupies the most number of pixels.

Each abstraction captures a specific reasoning pattern — such as spatial grouping, color-based dependency, neighborhood consistency, or relational alignment.  
By classifying a task into one or more abstractions, we identify *how* the task encodes relational information, not *what* it computes.

The Abstractions are:

1 — ccg — Connected Components Graph

Definition: Treat every contiguous region of pixels of the same non-background color as one object/node (standard connected components).
Visual cues: distinct contiguous blobs of solid colors; objects are separated by at least one background pixel; shapes are irregular or varied but color-homogeneous.
When to pick: when the image’s important structure is “objects” that are color-consistent connected regions (move/transform/relocate or recolor whole blobs). Good when objects are isolated by background.
When not to pick: when objects are defined by multi-color patterns inside a shape, or when the structure is a single large rectangle containing multiple colors, or when vertical/horizontal stripes matter more than blobs.

Mini-rationale example: “I pick ccg because I see several isolated solid-color blobs (each colored blob looks like a single object that might be moved or recolored).”



2 — nbccg — Non-Background Connected Components Graph

Definition: Like ccg, but explicitly ignores background color — focus only on connected components composed of non-background colors. (Often the same as ccg but useful to emphasize background-invariance.)
Visual cues: same as ccg, but the background is large, uniform and should be treated as empty space.
When to pick: when objects sit clearly on a uniform background and the background must not be treated as an object. Use if solving appears to require ignoring the background entirely.
When not to pick: when the background contains meaningful colored cells (e.g., tiled background patterns) or when background color changes across examples.

Mini-rationale example: “I pick nbccg because the scene has a uniform background and the relevant entities are non-background color islands.”


3 — nbvcg — Non-Background Vertical Components Graph

Definition: Treat vertical runs/columns (contiguous in the vertical direction) of non-background color as objects. Useful if vertical alignment/columns matter.
Visual cues: long vertical bars/columns or patterns that align vertically (columns of the same color), thin vertical strokes, or repeated vertical separators.
When to pick: when objects are column-like (tall and narrow), when behavior in tasks depends on vertical stacking/ordering, or when elements line up in columns.
When not to pick: when objects are compact blobs that are not elongated vertically, or when most structure is horizontal.

Mini-rationale example: “I pick nbvcg because the scene shows several long vertical columns of color (the task likely depends on column order or vertical adjacency).”



4 — mcccg — Multi-Color Connected Components Graph

Definition: Treat contiguous regions that may contain multiple colors as single multi-colored objects (the object is a shape that has internal color pattern). Each object keeps per-pixel color info.
Visual cues: objects with internal color patterns or gradients; shapes whose identity relies on the arrangement of colors inside them, not just the region boundary.
When to pick: when the transformation seems to act on the whole patterned shape (move, rotate, reflect) or when internal color arrangement matters for matching.
When not to pick: when objects are single-color blobs or when color changes are independent atomic objects.

Mini-rationale example: “I pick mcccg because each object contains an internal pattern of colors that looks important to preserve as a single unit.”


5 — lrg — Largest Rectangle Graph

Definition: Abstract the image by finding the largest axis-aligned rectangle(s) of uniform color (largest solid rectangles) and treat them as objects.
Visual cues: large rectangular blocks, grids of rectangles, or tasks where biggest rectangle(s) change/are moved/colored.
When to pick: when the image contains dominant rectangular shapes (vs. many small blobs) or when the task likely manipulates or compares largest-area rectangular regions.
When not to pick: when objects are non-rectangular, irregular, or many small pieces instead of one or few big rectangles.

Mini-rationale example: “I pick lrg because I see a single very large rectangular region that seems to be the primary object of transformation.”

6 — na — No Abstraction (pixel-level)

Definition: Don’t collapse pixels into higher-level nodes; treat the grid at pixel-level (or minimal grouping). Use when the solution requires fine-grained, per-pixel changes or the structure is too small/noisy for object grouping.
Visual cues: scattered, single-pixel signals; changes detectable only at the pixel level (like toggling a few pixels), fine-grained patterns, or transformations that alter pixel-by-pixel rather than whole objects.
When to pick: when objects are single pixels, patterns are tiny, or when changes are highly local and not well represented as objects.
When not to pick: when clear objects exist and transformations act on full shapes.

Mini-rationale example: “I pick na because the important differences are isolated single pixels and no clear multi-pixel objects exist.”


7 — nbhcg — Non-Background Horizontal Components Graph

Definition: Groups horizontally connected non-background pixels (continuous horizontal runs or stripes) as objects.
Visual cues:

Objects appear as long horizontal bars, rows, or color bands.

Patterns repeat across rows.

Transformations seem to act along the horizontal axis (shift, mirror, stack).
When to pick:

When the image has wide horizontal stripes or layered patterns.

When object relationships depend on horizontal adjacency or row alignment.

When transformations involve row-wise repetition, sliding, or deletion.
When not to pick:

When the image is vertically structured or column-driven (nbvcg fits better).

When shapes are small, discrete blobs (use ccg/nbccg).

Mini-rationale example:

“I pick nbhcg because the picture shows several wide horizontal color bands stacked on top of each other.”

8 — ccgbr — Connected Components Graph with Bounding Rectangles

Definition: Builds on ccg but represents each connected component by its bounding rectangle rather than its precise shape. Each object node corresponds to the smallest rectangle that encloses that blob.
Visual cues:

Objects are roughly rectangular or can be approximated by rectangles.

Exact pixel shape isn’t important; spatial extent or bounding boxes matter.

Tasks involve aligning, resizing, or comparing object extents rather than pixel-perfect details.
When to pick:

When you see rectangular objects, grids, or box-like regions that may shift or resize.

When shapes are nearly rectangular and bounding box position is the key property.
When not to pick:

When objects are highly irregular or non-rectangular.

When pixel-level structure inside objects matters.

Mini-rationale example:

“I pick ccgbr because each colored region is rectangular, and the task seems to depend on their positions or sizes rather than precise shapes.”

9 — ccgbr2 — Connected Components Graph with Extended Bounding Rectangles

Definition: A variant of ccgbr that merges nearby or overlapping bounding rectangles, producing slightly larger boxes. It’s useful when objects are composed of multiple small adjacent rectangles or when spacing between parts should be ignored.
Visual cues:

Groups of close rectangles or clusters of small blocks forming larger rectangular zones.

Slight gaps between parts that logically belong together.

Tasks where objects are meant to be treated as one larger region (filling, covering, merging).
When to pick:

When multiple small rectangular patches of the same color are near each other.

When the image looks like a broken grid that should be unified.
When not to pick:

When individual small rectangles should remain distinct.

When precise boundaries between rectangles matter.

Mini-rationale example:

“I pick ccgbr2 because several small rectangular regions of the same color are close together and should be treated as one larger area.”

Your Task is to:
1. Carefully observe the given JSON (its "input" and "output" grids in "train").
2. Analyze its structural and visual composition — patterns, groupings, colors, links, and layouts.
3. Match these cues with the abstraction guidelines above.
4. Select the three most plausible abstractions (ranked from most to least likely).
5. For each abstraction, provide a short reasoning note explaining *why* it fits.

After producing your answer, reflect on your reasoning:
-Is each abstraction choice supported by a clear visual pattern?
-Are there any alternative abstractions that could fit better?


